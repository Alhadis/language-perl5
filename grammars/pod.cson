name: "Pod"
scopeName: "text.pod"
patterns: [
	{include: "#commands"}
	{include: "#verbatim"}
	{include: "#paragraph"}
]

repository:

	# Command paragraphs: =[…name]
	commands:
		patterns: [
			{include: "#heading"}
			{include: "#encoding"}
			{include: "#overhang"}
			{include: "#list"}
			{include: "#formatBlocks"}
			{include: "#formatLines"}
			
			# Some other command not listed in perlpod(1)
			match: "^((=)\\S*)"
			captures:
				1: name: "storage.type.class.command.pod"
				2: name: "punctuation.definition.command.pod"
		]


	# End Pod: =cut
	cut:
		match: "^((=)cut)(?:\\s+\\S.*)?\\s*$"
		captures:
			1: name: "storage.type.class.cut.pod"
			2: name: "punctuation.section.end.pod"


	# Embedded highlighting. Boundaries are clamped to stop runaway matches.
	embedHTML:
		name:  "text.embedded.html.basic"
		match: "(?:^|\\n|\\G)\\s*(\\S.*)$\\n?"
		captures:
			0: patterns: [include: "text.html.basic"]

	embedRoff:
		name:  "text.embedded.roff"
		match: "(?:^|\\n|\\G)\\s*(\\S.*)$\\n?"
		captures:
			0: patterns: [include: "text.roff"]

	embedLatex:
		name:  "text.embedded.latex"
		match: "(?:^|\\n|\\G)\\s*(\\S.*)$\\n?"
		captures:
			0: patterns: [include: "text.tex.latex"]

	embedTex:
		name:  "text.embedded.tex"
		match: "(?:^|\\n|\\G)\\s*(\\S.*)$\\n?"
		captures:
			0: patterns: [include: "text.tex"]

	embedText:
		name:  "text.embedded.plain"
		match: "(?:^|\\n|\\G)\\s*\\S.*$\\n?"


	# Document encoding: =encoding [name]
	encoding:
		match: "^((=)encoding)(?:\\s+(\\S.*)?)\\s*$"
		captures:
			1: name: "storage.type.class.encoding.pod"
			2: name: "punctuation.definition.command.pod"
			3: name: "entity.name.type.instance.encoding-type.pod"


	# Embedded region of text/code/data.
	#    =begin [format-name]
	#           [empty-line] …content… [empty-line]
	#    =end   [format-name]
	formatBlocks:
		patterns: [{
			# =begin html
			# <h1 class="etc">HTML source</h1>
			# =end html
			name:  "meta.embedded-html.format.block.pod"
			begin: "^((=)begin)\\s+(html)(?=\\s|$)"
			end:   "^((=)end)\\s+(html)|^(?==cut(?:\\s|$))"
			beginCaptures:
				1: name: "storage.type.class.format.begin.pod"
				2: name: "punctuation.section.format.begin.pod"
				3: name: "entity.name.type.instance.pod"
			endCaptures:
				1: name: "storage.type.class.format.end.pod"
				2: name: "punctuation.section.format.end.pod"
				3: name: "entity.name.type.instance.pod"
			patterns: [
				{include: "#ignoreUntilEmptyLine"}
				
				# Highlighted HTML
				name:  "meta.output.format.pod"
				begin: "(?<=^|\\n)(\\s*\\S.*\\s*)$\\n?"
				end:   "(?<=^|\\n)(?=\\s*$)"
				beginCaptures: 1: patterns: [include: "#embedHTML"]
				patterns:                   [include: "#embedHTML"]
			]
		},{
			# =begin [roff|man]
			# .de XS \\n(.X \" etc
			# =end [roff|man]
			name:  "meta.embedded-roff.format.block.pod"
			begin: "^((=)begin)\\s+(roff|man)(?=\\s|$)"
			end:   "^((=)end)\\s+(\\3)|^(?==cut(?:\\s|$))"
			beginCaptures:
				1: name: "storage.type.class.format.begin.pod"
				2: name: "punctuation.section.format.begin.pod"
				3: name: "entity.name.type.instance.pod"
			endCaptures:
				1: name: "storage.type.class.format.end.pod"
				2: name: "punctuation.section.format.end.pod"
				3: name: "entity.name.type.instance.pod"
			patterns: [
				{include: "#ignoreUntilEmptyLine"}
				
				# Highlighted Roff: https://github.com/Alhadis/language-roff
				name:  "meta.output.format.pod"
				begin: "(?<=^|\\n)(\\s*\\S.*\\s*)$\\n?"
				end:   "(?<=^|\\n)(?=\\s*$)"
				beginCaptures: 1: patterns: [include: "#embedRoff"]
				patterns:                   [include: "#embedRoff"]
			]
		},{
			# =begin latex
			# \{latex} LaTeX
			# =end latex
			name:  "meta.embedded-latex.format.block.pod"
			begin: "^((=)begin)\\s+(latex)(?=\\s|$)"
			end:   "^((=)end)\\s+(latex)|^(?==cut(?:\\s|$))"
			beginCaptures:
				1: name: "storage.type.class.format.begin.pod"
				2: name: "punctuation.section.format.begin.pod"
				3: name: "entity.name.type.instance.pod"
			endCaptures:
				1: name: "storage.type.class.format.end.pod"
				2: name: "punctuation.section.format.end.pod"
				3: name: "entity.name.type.instance.pod"
			patterns: [
				{include: "#ignoreUntilEmptyLine"}
				
				# Highlighted LaTeX
				name:  "meta.output.format.pod"
				begin: "(?<=^|\\n)(\\s*\\S.*\\s*)$\\n?"
				end:   "(?<=^|\\n)(?=\\s*$)"
				beginCaptures: 1: patterns: [include: "#embedLatex"]
				patterns:                   [include: "#embedLatex"]
			]
		},{
			# =begin tex
			# \mathcode`\+="202B  Plain old TeX?
			# =end tex
			name:  "meta.embedded-tex.format.block.pod"
			begin: "^((=)begin)\\s+(tex)(?=\\s|$)"
			end:   "^((=)end)\\s+(tex)|^(?==cut(?:\\s|$))"
			beginCaptures:
				1: name: "storage.type.class.format.begin.pod"
				2: name: "punctuation.section.format.begin.pod"
				3: name: "entity.name.type.instance.pod"
			endCaptures:
				1: name: "storage.type.class.format.end.pod"
				2: name: "punctuation.section.format.end.pod"
				3: name: "entity.name.type.instance.pod"
			patterns: [
				{include: "#ignoreUntilEmptyLine"}
				
				# Highlighted TeX
				name:  "meta.output.format.pod"
				begin: "(?<=^|\\n)(\\s*\\S.*\\s*)$\\n?"
				end:   "(?<=^|\\n)(?=\\s*$)"
				beginCaptures: 1: patterns: [include: "#embedTex"]
				patterns:                   [include: "#embedTex"]
			]
		},{
			# =begin text
			# Plain old text
			# =end text
			name:  "meta.embedded-text.format.block.pod"
			begin: "^((=)begin)\\s+(text)(?=\\s|$)"
			end:   "^((=)end)\\s+(text)|^(?==cut(?:\\s|$))"
			beginCaptures:
				1: name: "storage.type.class.format.begin.pod"
				2: name: "punctuation.section.format.begin.pod"
				3: name: "entity.name.type.instance.pod"
			endCaptures:
				1: name: "storage.type.class.format.end.pod"
				2: name: "punctuation.section.format.end.pod"
				3: name: "entity.name.type.instance.pod"
			patterns: [
				{include: "#ignoreUntilEmptyLine"}
				
				# Unhighlighted text
				name:  "meta.output.format.pod"
				begin: "(?<=^|\\n)(\\s*\\S.*)$\\n?"
				end:   "(?<=^|\\n)(?=\\s*$)"
				beginCaptures: 1: patterns: [include: "#embedText"]
				patterns:                   [include: "#embedText"]
			]
		},{
			# =begin :actualpod
			# Plain old Pod (Plain old plain old documentation)
			# =end :actualpod
			name:  "meta.embedded-pod.format.block.pod"
			match: "^((=)(begin|end))\\s+((:)\\S+)"
			captures:
				1: name: "storage.type.class.format.$3.pod"
				2: name: "punctuation.section.format.$3.pod"
				4: name: "entity.name.type.instance.pod"
				5: name: "punctuation.separator.colon.format.pod"
		},{
			# =begin [unknown-format]
			# =end [unknown-format]
			name:  "meta.embedded-$3.format.block.other.pod"
			begin: "^((=)begin)\\s+((?!:)\\S+)"
			end:   "^((=)end)\\s+(\\3)|^(?==cut(?:\\s|$))"
			beginCaptures:
				1: name: "storage.type.class.format.begin.pod"
				2: name: "punctuation.section.format.begin.pod"
				3: name: "entity.name.type.instance.pod"
			endCaptures:
				1: name: "storage.type.class.format.end.pod"
				2: name: "punctuation.section.format.end.pod"
				3: name: "entity.name.type.instance.pod"
			contentName: "meta.output.format.pod"
		}]


	# Line of embedded text/code/data
	#    =for [format-name] [text]
	formatLines:
		patterns: [{
			# =for html [input]
			name:  "meta.embedded-html.format.line.pod"
			begin: "^((=)for)\\s+(html)(?=\\s|$)\\s*"
			end:   "^(?=\\s*$)|^(?==cut(?:\\s|$))"
			beginCaptures:
				1: name: "storage.type.class.format.pod"
				2: name: "punctuation.section.format.pod"
				3: name: "entity.name.type.instance.pod"
			contentName:  "meta.output.format.pod"
			patterns: [include: "#embedHTML"]
		},{
			# =for roff [input]
			# =for man  [input]
			name:  "meta.embedded-roff.format.line.pod"
			begin: "^((=)for)\\s+(roff|man)(?=\\s|$)\\s*"
			end:   "^(?=\\s*$)|^(?==cut(?:\\s|$))"
			beginCaptures:
				1: name: "storage.type.class.format.pod"
				2: name: "punctuation.section.format.pod"
				3: name: "entity.name.type.instance.pod"
			contentName:  "meta.output.format.pod"
			patterns: [include: "#embedRoff"]
		},{
			# =for latex [input]
			name:  "meta.embedded-latex.format.line.pod"
			begin: "^((=)for)\\s+(latex)(?=\\s|$)\\s*"
			end:   "^(?=\\s*$)|^(?==cut(?:\\s|$))"
			beginCaptures:
				1: name: "storage.type.class.format.pod"
				2: name: "punctuation.section.format.pod"
				3: name: "entity.name.type.instance.pod"
			contentName:  "meta.output.format.pod"
			patterns: [include: "#embedLatex"]
		},{
			# =for tex [input]
			name:  "meta.embedded-tex.format.line.pod"
			begin: "^((=)for)\\s+(tex)(?=\\s|$)\\s*"
			end:   "^(?=\\s*$)|^(?==cut(?:\\s|$))"
			beginCaptures:
				1: name: "storage.type.class.format.pod"
				2: name: "punctuation.section.format.pod"
				3: name: "entity.name.type.instance.pod"
			contentName: "meta.output.format.pod"
			patterns: [include: "#embedTex"]
		},{
			# =for text [input]
			name:  "meta.embedded-text.format.line.pod"
			begin: "^((=)for)\\s+(text)(?=\\s|$)\\s*"
			end:   "^(?=\\s*$)|^(?==cut(?:\\s|$))"
			beginCaptures:
				1: name: "storage.type.class.format.pod"
				2: name: "punctuation.section.format.pod"
				3: name: "entity.name.type.instance.pod"
			contentName: "meta.output.format.pod"
			patterns: [include: "#embedText"]
		},{
			# =for comment {Ignored in formatted documentation}
			name:  "meta.ignored.format.line.pod"
			begin: "^((=)for)\\s+(comment)(?=\\s|$)"
			end:   "^(?=\\s*$)|^(?==cut(?:\\s|$))"
			beginCaptures:
				1: name: "storage.type.class.format.pod"
				2: name: "punctuation.section.format.pod"
				3: name: "entity.name.type.instance.pod"
			contentName: "constant.other.ignored-text.pod"
		},{
			# =for :[…anything] Actual Pod code
			name:  "meta.embedded-pod.format.line.pod"
			begin: "^((=)for)\\s+((:)\\S+)(?=\\s|$)"
			end:   "^(?=\\s*$)|^(?==cut(?:\\s|$))"
			beginCaptures:
				1: name: "storage.type.class.format.pod"
				2: name: "punctuation.section.format.pod"
				3: name: "entity.name.type.instance.pod"
				4: name: "punctuation.separator.colon.format.pod"
			patterns: [include: "#params"]
		},{
			# =for [unknown-format] Anything else
			name:  "meta.embedded-$3.format.line.other.pod"
			begin: "^((=)for)\\s+((?!:)\\S+)(?=\\s|$)"
			end:   "^(?=\\s*$)|^(?==cut(?:\\s|$))"
			beginCaptures:
				1: name: "storage.type.class.format.begin.pod"
				2: name: "punctuation.section.format.begin.pod"
				3: name: "entity.name.type.instance.pod"
			contentName: "meta.output.format.pod"
		}]


	# Headings: =head[1…4]
	heading:
		name:  "markup.heading.$3.pod"
		begin: "^((=)head([1-4]))(?:\\s+(\\S.*))?\\s*$"
		end:   "^(?=\\s*$)|^(?==cut(?:\\s|$))"
		beginCaptures:
			1: name: "storage.type.class.heading.pod"
			2: name: "punctuation.definition.heading.pod"
			4: patterns: [include: "#inline"]


	# Markup tags for basic inline styling: **bold**, _italic_, `monospaced`, etc…
	inline:
		patterns: [
			{include: "#inlineItalic"}
			{include: "#inlineBold"}
			{include: "#inlineCode"}
			{include: "#inlineLink"}
		]


	# Oblique/slanted, emphasised, and/or italic text
	inlineItalic:
		name:  "entity.name.type.instance.pod"
		begin: "I(<)"
		end:   "(>)|^(?==)"
		beginCaptures:
			0: name: "entity.name.inline.tag.begin.italic.pod"
			1: name: "punctuation.definition.style.italic.begin.pod"
		endCaptures:
			0: name: "entity.name.inline.tag.end.italic.pod"
			1: name: "punctuation.definition.style.italic.end.pod"
		contentName: "markup.italic.pod"
		patterns: [include: "#inline"]
	
	
	# Bold, heavy, and/or "strong" text
	inlineBold:
		name:  "entity.name.type.instance.pod"
		begin: "B(<)"
		end:   "(>)|^(?==)"
		beginCaptures:
			0: name: "entity.name.inline.tag.begin.bold.pod"
			1: name: "punctuation.definition.style.bold.begin.pod"
		endCaptures:
			0: name: "entity.name.inline.tag.end.bold.pod"
			1: name: "punctuation.definition.style.bold.end.pod"
		contentName: "markup.bold.pod"
		patterns: [include: "#inline"]
	
	
	# `Monospaced type`, or so-called “code text”
	inlineCode:
		name:  "entity.name.type.instance.pod"
		begin: "C(<)"
		end:   "(>)|^(?==)"
		beginCaptures:
			0: name: "entity.name.inline.tag.begin.raw.monospaced.pod"
			1: name: "punctuation.definition.style.raw.monospaced.begin.pod"
		endCaptures:
			0: name: "entity.name.inline.tag.end.raw.monospaced.pod"
			1: name: "punctuation.definition.style.raw.monospaced.end.pod"
		contentName: "markup.raw.monospaced.pod"
		patterns: [include: "#inline"]

	
	# Hyperlink or page reference.
	#
	# NOTE: To satisfy both Atom themes _and_ GitHub's fickle highlighting palette, we
	# add an excess of scope-names. This way we grant maximum styling control to users
	# and theme authors, yet maintain pleasing colouration when displayed on GitHub.
	inlineLink:
		name:  "entity.name.type.instance.link.pod"
		begin: "(L(<))(\\s*)"
		end:   "(\\s*)(>)|^(?==)"
		beginCaptures:
			1: name: "entity.name.inline.tag.begin.link.pod"
			2: name: "punctuation.definition.link.begin.pod"
			3: name: "invalid.illegal.syntax.leading.whitespace.pod"
		endCaptures:
			1: name: "invalid.illegal.syntax.trailing.whitespace.pod"
			2: name: "punctuation.definition.link.end.pod"
		patterns: [{
			# L< …Displayed text… |
			name: "meta.manpage.unix.link.label.pod"
			match: "\\G((?:[^\\s|>][^|>]+)?)(\\|)"
			captures:
				1: name: "constant.other.description.pod"
				2: name: "punctuation.separator.key-value.pipe.pod"
		},{
			# L<grep(1)> - Unix manpage link
			include: "#manpageRef"
		},{
			# L<name/section> - Perl manpage link and/or possible section reference
			name:  "entity.type.manpage.perldoc.link.pod"
			begin: "\\G(\\/)|\\G([\\w:|]+)(\\/)?"
			end:   "(?=\\s*>)"
			beginCaptures:
				1: name: "punctuation.separator.slash.section.link.pod"
				2: name: "variable.markup.underline.link.pod"
				3: name: "punctuation.separator.slash.section.link.pod"
			patterns: [{
				# …/section-reference…
				name:  "meta.manpage.section.cross-reference.link.pod"
				begin: "\\G/"
				end:   "(?=\\s*>)"
				beginCaptures:
					0: name: "punctuation.separator.slash.section.link.pod"
				patterns: [{
					# /…"Quoted section name"…
					name:  "variable.markup.underline.link.pod"
					begin: '\\G"'
					end:   '"'
					contentName: "string.quoted.double.section.name.link.pod"
					beginCaptures: 0: name: "punctuation.definition.string.begin.pod"
					endCaptures:   0: name: "punctuation.definition.string.end.pod"
				},{
					# /…Unquoted section…
					name:  "variable.markup.underline.link.pod"
					begin: '\\G\\s*([^>"\\s]+)'
					end:   "(?=\\s*>)"
					beginCaptures: 0: name: "string.unquoted.other.section.name.link.pod"
					contentName:            "string.unquoted.other.section.name.link.pod"
				}]
			}]
		},{
			# Fallback: underline anything we haven't already matched
			match: "[^\\s|<>]+"
			name: "variable.markup.underline.link.pod"
		}]
	
	
	# grep(1) - Unix manual-page reference
	manpageRef:
		name: "entity.type.manpage.unix.link.pod"
		match: """(?x) \\G
			# 1: Label
			(
				([^\\s|][^|>]+)       # 2: Possible text-label
				(\\|)                 # 3: Separator
			)?
			# 4: Destination
			(
				([^()<>\\s]+)         # 5: Topic
				(\\()                 # 6: (
				([0-9])               # 7: Section number
				((?![0-9])\\w{0,3})?  # 8: Section group/suffix
				(\\))                 # 9: )
			)
		"""
		captures:
			1: name: "meta.manpage.unix.link.label.pod"
			2: name: "constant.other.description.pod"
			3: name: "punctuation.separator.key-value.pipe.pod"
			4: name: "meta.manpage.unix.link.destination.pod"
			5: name: "entity.name.topic.link.pod"
			6: name: "punctuation.definition.manpage.section.begin.link.pod"
			7: name: "constant.numeric.integer.section.link.pod"
			8: name: "constant.language.section.suffix.link.pod"
			9: name: "punctuation.definition.manpage.section.end.link.pod"
		

	# Hack to ignore text between a command paragraph and the next blank line
	ignoreUntilEmptyLine:
		begin: "\\G"
		end: "(?<=^)(?=\\s*$)"


	# List item: =item
	list:
		patterns: [{
			# =item 1. Numbered
			name:  "markup.list.numbered.pod"
			begin: "^((=)item)\\s+(\\d+\\.)(?=\\s|$)"
			end:   "^(?=\\s*$)|^(?==cut(?:\\s|$))"
			beginCaptures:
				1: name: "storage.type.class.list.pod"
				2: name: "punctuation.definition.list.pod"
				3: name: "variable.ordered.list.pod"
			patterns: [include: "#inline"]
		},{
			# =item * Bulleted
			name:  "markup.list.unnumbered.pod"
			begin: "^((=)item)\\s+(\\d+\\.)(?=\\s|$)"
			end:   "^(?=\\s*$)|^(?==cut(?:\\s|$))"
			beginCaptures:
				1: name: "storage.type.class.list.pod"
				2: name: "punctuation.definition.list.pod"
				3: name: "variable.unordered.list.pod"
			patterns: [include: "#inline"]
		},{
			# =item Anything else
			name:  "markup.list.other.pod"
			begin: "^((=)item)(?=\\s|$)"
			end:   "^(?=\\s*$)|^(?==cut(?:\\s|$))"
			beginCaptures:
				1: name: "storage.type.class.list.pod"
				2: name: "punctuation.definition.list.pod"
			patterns: [include: "#inline"]
		}]
	
	
	# Overhanging list or indented paragraph
	#    =over [indent-level]  - Begin list
	#    =item [item-text]     - List item
	#    =back                 - End list
	overhang:
		name:  "meta.overhang.pod"
		begin: "^((=)over)(?:\\s+(\\S.*))?\\s*$"
		end:   "^((=)back)(?:\\b.*$)|^(?==cut(?:\\s|$))"
		beginCaptures:
			1: name: "storage.type.class.list.begin.pod"
			2: name: "punctuation.section.list.begin.pod"
			3: name: "constant.language.numeric.indent-level.pod"
		endCaptures:
			1: name: "storage.type.class.list.end.pod"
			2: name: "punctuation.section.list.end.pod"
		patterns: [include: "text.pod"]


	# Fallback highlighting for arguments to unrecognised commands
	params:
		name: "variable.other.parameter.argument.pod"
		match: "\\S+"


	# Ordinary text block
	paragraph:
		name:  "markup.paragraph.pod"
		begin: "^(?=[^\\s=])|^\\s+(?=\\S)"
		end:   "^(?=\\s*$)"
		patterns: [include: "#inline"]


	# Indented text block, representing "verbatim" text (à la, Markdown)
	verbatim:
		name:  "markup.raw.code.verbatim.pod"
		begin: "^(?=[ \\t])"
		end:   "^(?=\\s*$)"
		patterns: [
			name: "punctuation.leading.whitespace.pod"
			match: "(?:^|\\G)[ \\t]+"
		]
